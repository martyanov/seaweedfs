// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: volume.proto

package rpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// VolumeClient is the client API for Volume service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VolumeClient interface {
	//Experts only: takes multiple fid parameters. This function does not propagate deletes to replicas.
	BatchDelete(ctx context.Context, in *BatchDeleteRequest, opts ...grpc.CallOption) (*BatchDeleteResponse, error)
	VacuumVolumeCheck(ctx context.Context, in *VacuumVolumeCheckRequest, opts ...grpc.CallOption) (*VacuumVolumeCheckResponse, error)
	VacuumVolumeCompact(ctx context.Context, in *VacuumVolumeCompactRequest, opts ...grpc.CallOption) (Volume_VacuumVolumeCompactClient, error)
	VacuumVolumeCommit(ctx context.Context, in *VacuumVolumeCommitRequest, opts ...grpc.CallOption) (*VacuumVolumeCommitResponse, error)
	VacuumVolumeCleanup(ctx context.Context, in *VacuumVolumeCleanupRequest, opts ...grpc.CallOption) (*VacuumVolumeCleanupResponse, error)
	DeleteCollection(ctx context.Context, in *DeleteCollectionRequest, opts ...grpc.CallOption) (*DeleteCollectionResponse, error)
	AllocateVolume(ctx context.Context, in *AllocateVolumeRequest, opts ...grpc.CallOption) (*AllocateVolumeResponse, error)
	VolumeSyncStatus(ctx context.Context, in *VolumeSyncStatusRequest, opts ...grpc.CallOption) (*VolumeSyncStatusResponse, error)
	VolumeIncrementalCopy(ctx context.Context, in *VolumeIncrementalCopyRequest, opts ...grpc.CallOption) (Volume_VolumeIncrementalCopyClient, error)
	VolumeMount(ctx context.Context, in *VolumeMountRequest, opts ...grpc.CallOption) (*VolumeMountResponse, error)
	VolumeUnmount(ctx context.Context, in *VolumeUnmountRequest, opts ...grpc.CallOption) (*VolumeUnmountResponse, error)
	VolumeDelete(ctx context.Context, in *VolumeDeleteRequest, opts ...grpc.CallOption) (*VolumeDeleteResponse, error)
	VolumeMarkReadonly(ctx context.Context, in *VolumeMarkReadonlyRequest, opts ...grpc.CallOption) (*VolumeMarkReadonlyResponse, error)
	VolumeMarkWritable(ctx context.Context, in *VolumeMarkWritableRequest, opts ...grpc.CallOption) (*VolumeMarkWritableResponse, error)
	VolumeConfigure(ctx context.Context, in *VolumeConfigureRequest, opts ...grpc.CallOption) (*VolumeConfigureResponse, error)
	VolumeStatus(ctx context.Context, in *VolumeStatusRequest, opts ...grpc.CallOption) (*VolumeStatusResponse, error)
	// copy the .idx .dat files, and mount this volume
	VolumeCopy(ctx context.Context, in *VolumeCopyRequest, opts ...grpc.CallOption) (Volume_VolumeCopyClient, error)
	ReadVolumeFileStatus(ctx context.Context, in *ReadVolumeFileStatusRequest, opts ...grpc.CallOption) (*ReadVolumeFileStatusResponse, error)
	CopyFile(ctx context.Context, in *CopyFileRequest, opts ...grpc.CallOption) (Volume_CopyFileClient, error)
	ReadNeedleBlob(ctx context.Context, in *ReadNeedleBlobRequest, opts ...grpc.CallOption) (*ReadNeedleBlobResponse, error)
	WriteNeedleBlob(ctx context.Context, in *WriteNeedleBlobRequest, opts ...grpc.CallOption) (*WriteNeedleBlobResponse, error)
	ReadAllNeedles(ctx context.Context, in *ReadAllNeedlesRequest, opts ...grpc.CallOption) (Volume_ReadAllNeedlesClient, error)
	VolumeTailSender(ctx context.Context, in *VolumeTailSenderRequest, opts ...grpc.CallOption) (Volume_VolumeTailSenderClient, error)
	VolumeTailReceiver(ctx context.Context, in *VolumeTailReceiverRequest, opts ...grpc.CallOption) (*VolumeTailReceiverResponse, error)
	// erasure coding
	VolumeEcShardsGenerate(ctx context.Context, in *VolumeEcShardsGenerateRequest, opts ...grpc.CallOption) (*VolumeEcShardsGenerateResponse, error)
	VolumeEcShardsRebuild(ctx context.Context, in *VolumeEcShardsRebuildRequest, opts ...grpc.CallOption) (*VolumeEcShardsRebuildResponse, error)
	VolumeEcShardsCopy(ctx context.Context, in *VolumeEcShardsCopyRequest, opts ...grpc.CallOption) (*VolumeEcShardsCopyResponse, error)
	VolumeEcShardsDelete(ctx context.Context, in *VolumeEcShardsDeleteRequest, opts ...grpc.CallOption) (*VolumeEcShardsDeleteResponse, error)
	VolumeEcShardsMount(ctx context.Context, in *VolumeEcShardsMountRequest, opts ...grpc.CallOption) (*VolumeEcShardsMountResponse, error)
	VolumeEcShardsUnmount(ctx context.Context, in *VolumeEcShardsUnmountRequest, opts ...grpc.CallOption) (*VolumeEcShardsUnmountResponse, error)
	VolumeEcShardRead(ctx context.Context, in *VolumeEcShardReadRequest, opts ...grpc.CallOption) (Volume_VolumeEcShardReadClient, error)
	VolumeEcBlobDelete(ctx context.Context, in *VolumeEcBlobDeleteRequest, opts ...grpc.CallOption) (*VolumeEcBlobDeleteResponse, error)
	VolumeEcShardsToVolume(ctx context.Context, in *VolumeEcShardsToVolumeRequest, opts ...grpc.CallOption) (*VolumeEcShardsToVolumeResponse, error)
	// tiered storage
	VolumeTierMoveDatToRemote(ctx context.Context, in *VolumeTierMoveDatToRemoteRequest, opts ...grpc.CallOption) (Volume_VolumeTierMoveDatToRemoteClient, error)
	VolumeTierMoveDatFromRemote(ctx context.Context, in *VolumeTierMoveDatFromRemoteRequest, opts ...grpc.CallOption) (Volume_VolumeTierMoveDatFromRemoteClient, error)
	VolumeServerStatus(ctx context.Context, in *VolumeServerStatusRequest, opts ...grpc.CallOption) (*VolumeServerStatusResponse, error)
	VolumeServerLeave(ctx context.Context, in *VolumeServerLeaveRequest, opts ...grpc.CallOption) (*VolumeServerLeaveResponse, error)
	// remote storage
	FetchAndWriteNeedle(ctx context.Context, in *FetchAndWriteNeedleRequest, opts ...grpc.CallOption) (*FetchAndWriteNeedleResponse, error)
	// <experimental> query
	Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (Volume_QueryClient, error)
	VolumeNeedleStatus(ctx context.Context, in *VolumeNeedleStatusRequest, opts ...grpc.CallOption) (*VolumeNeedleStatusResponse, error)
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error)
}

type volumeClient struct {
	cc grpc.ClientConnInterface
}

func NewVolumeClient(cc grpc.ClientConnInterface) VolumeClient {
	return &volumeClient{cc}
}

func (c *volumeClient) BatchDelete(ctx context.Context, in *BatchDeleteRequest, opts ...grpc.CallOption) (*BatchDeleteResponse, error) {
	out := new(BatchDeleteResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/BatchDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) VacuumVolumeCheck(ctx context.Context, in *VacuumVolumeCheckRequest, opts ...grpc.CallOption) (*VacuumVolumeCheckResponse, error) {
	out := new(VacuumVolumeCheckResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/VacuumVolumeCheck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) VacuumVolumeCompact(ctx context.Context, in *VacuumVolumeCompactRequest, opts ...grpc.CallOption) (Volume_VacuumVolumeCompactClient, error) {
	stream, err := c.cc.NewStream(ctx, &Volume_ServiceDesc.Streams[0], "/weed.volume.Volume/VacuumVolumeCompact", opts...)
	if err != nil {
		return nil, err
	}
	x := &volumeVacuumVolumeCompactClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Volume_VacuumVolumeCompactClient interface {
	Recv() (*VacuumVolumeCompactResponse, error)
	grpc.ClientStream
}

type volumeVacuumVolumeCompactClient struct {
	grpc.ClientStream
}

func (x *volumeVacuumVolumeCompactClient) Recv() (*VacuumVolumeCompactResponse, error) {
	m := new(VacuumVolumeCompactResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *volumeClient) VacuumVolumeCommit(ctx context.Context, in *VacuumVolumeCommitRequest, opts ...grpc.CallOption) (*VacuumVolumeCommitResponse, error) {
	out := new(VacuumVolumeCommitResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/VacuumVolumeCommit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) VacuumVolumeCleanup(ctx context.Context, in *VacuumVolumeCleanupRequest, opts ...grpc.CallOption) (*VacuumVolumeCleanupResponse, error) {
	out := new(VacuumVolumeCleanupResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/VacuumVolumeCleanup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) DeleteCollection(ctx context.Context, in *DeleteCollectionRequest, opts ...grpc.CallOption) (*DeleteCollectionResponse, error) {
	out := new(DeleteCollectionResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/DeleteCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) AllocateVolume(ctx context.Context, in *AllocateVolumeRequest, opts ...grpc.CallOption) (*AllocateVolumeResponse, error) {
	out := new(AllocateVolumeResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/AllocateVolume", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) VolumeSyncStatus(ctx context.Context, in *VolumeSyncStatusRequest, opts ...grpc.CallOption) (*VolumeSyncStatusResponse, error) {
	out := new(VolumeSyncStatusResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/VolumeSyncStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) VolumeIncrementalCopy(ctx context.Context, in *VolumeIncrementalCopyRequest, opts ...grpc.CallOption) (Volume_VolumeIncrementalCopyClient, error) {
	stream, err := c.cc.NewStream(ctx, &Volume_ServiceDesc.Streams[1], "/weed.volume.Volume/VolumeIncrementalCopy", opts...)
	if err != nil {
		return nil, err
	}
	x := &volumeVolumeIncrementalCopyClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Volume_VolumeIncrementalCopyClient interface {
	Recv() (*VolumeIncrementalCopyResponse, error)
	grpc.ClientStream
}

type volumeVolumeIncrementalCopyClient struct {
	grpc.ClientStream
}

func (x *volumeVolumeIncrementalCopyClient) Recv() (*VolumeIncrementalCopyResponse, error) {
	m := new(VolumeIncrementalCopyResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *volumeClient) VolumeMount(ctx context.Context, in *VolumeMountRequest, opts ...grpc.CallOption) (*VolumeMountResponse, error) {
	out := new(VolumeMountResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/VolumeMount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) VolumeUnmount(ctx context.Context, in *VolumeUnmountRequest, opts ...grpc.CallOption) (*VolumeUnmountResponse, error) {
	out := new(VolumeUnmountResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/VolumeUnmount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) VolumeDelete(ctx context.Context, in *VolumeDeleteRequest, opts ...grpc.CallOption) (*VolumeDeleteResponse, error) {
	out := new(VolumeDeleteResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/VolumeDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) VolumeMarkReadonly(ctx context.Context, in *VolumeMarkReadonlyRequest, opts ...grpc.CallOption) (*VolumeMarkReadonlyResponse, error) {
	out := new(VolumeMarkReadonlyResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/VolumeMarkReadonly", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) VolumeMarkWritable(ctx context.Context, in *VolumeMarkWritableRequest, opts ...grpc.CallOption) (*VolumeMarkWritableResponse, error) {
	out := new(VolumeMarkWritableResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/VolumeMarkWritable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) VolumeConfigure(ctx context.Context, in *VolumeConfigureRequest, opts ...grpc.CallOption) (*VolumeConfigureResponse, error) {
	out := new(VolumeConfigureResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/VolumeConfigure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) VolumeStatus(ctx context.Context, in *VolumeStatusRequest, opts ...grpc.CallOption) (*VolumeStatusResponse, error) {
	out := new(VolumeStatusResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/VolumeStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) VolumeCopy(ctx context.Context, in *VolumeCopyRequest, opts ...grpc.CallOption) (Volume_VolumeCopyClient, error) {
	stream, err := c.cc.NewStream(ctx, &Volume_ServiceDesc.Streams[2], "/weed.volume.Volume/VolumeCopy", opts...)
	if err != nil {
		return nil, err
	}
	x := &volumeVolumeCopyClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Volume_VolumeCopyClient interface {
	Recv() (*VolumeCopyResponse, error)
	grpc.ClientStream
}

type volumeVolumeCopyClient struct {
	grpc.ClientStream
}

func (x *volumeVolumeCopyClient) Recv() (*VolumeCopyResponse, error) {
	m := new(VolumeCopyResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *volumeClient) ReadVolumeFileStatus(ctx context.Context, in *ReadVolumeFileStatusRequest, opts ...grpc.CallOption) (*ReadVolumeFileStatusResponse, error) {
	out := new(ReadVolumeFileStatusResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/ReadVolumeFileStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) CopyFile(ctx context.Context, in *CopyFileRequest, opts ...grpc.CallOption) (Volume_CopyFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &Volume_ServiceDesc.Streams[3], "/weed.volume.Volume/CopyFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &volumeCopyFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Volume_CopyFileClient interface {
	Recv() (*CopyFileResponse, error)
	grpc.ClientStream
}

type volumeCopyFileClient struct {
	grpc.ClientStream
}

func (x *volumeCopyFileClient) Recv() (*CopyFileResponse, error) {
	m := new(CopyFileResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *volumeClient) ReadNeedleBlob(ctx context.Context, in *ReadNeedleBlobRequest, opts ...grpc.CallOption) (*ReadNeedleBlobResponse, error) {
	out := new(ReadNeedleBlobResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/ReadNeedleBlob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) WriteNeedleBlob(ctx context.Context, in *WriteNeedleBlobRequest, opts ...grpc.CallOption) (*WriteNeedleBlobResponse, error) {
	out := new(WriteNeedleBlobResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/WriteNeedleBlob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) ReadAllNeedles(ctx context.Context, in *ReadAllNeedlesRequest, opts ...grpc.CallOption) (Volume_ReadAllNeedlesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Volume_ServiceDesc.Streams[4], "/weed.volume.Volume/ReadAllNeedles", opts...)
	if err != nil {
		return nil, err
	}
	x := &volumeReadAllNeedlesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Volume_ReadAllNeedlesClient interface {
	Recv() (*ReadAllNeedlesResponse, error)
	grpc.ClientStream
}

type volumeReadAllNeedlesClient struct {
	grpc.ClientStream
}

func (x *volumeReadAllNeedlesClient) Recv() (*ReadAllNeedlesResponse, error) {
	m := new(ReadAllNeedlesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *volumeClient) VolumeTailSender(ctx context.Context, in *VolumeTailSenderRequest, opts ...grpc.CallOption) (Volume_VolumeTailSenderClient, error) {
	stream, err := c.cc.NewStream(ctx, &Volume_ServiceDesc.Streams[5], "/weed.volume.Volume/VolumeTailSender", opts...)
	if err != nil {
		return nil, err
	}
	x := &volumeVolumeTailSenderClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Volume_VolumeTailSenderClient interface {
	Recv() (*VolumeTailSenderResponse, error)
	grpc.ClientStream
}

type volumeVolumeTailSenderClient struct {
	grpc.ClientStream
}

func (x *volumeVolumeTailSenderClient) Recv() (*VolumeTailSenderResponse, error) {
	m := new(VolumeTailSenderResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *volumeClient) VolumeTailReceiver(ctx context.Context, in *VolumeTailReceiverRequest, opts ...grpc.CallOption) (*VolumeTailReceiverResponse, error) {
	out := new(VolumeTailReceiverResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/VolumeTailReceiver", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) VolumeEcShardsGenerate(ctx context.Context, in *VolumeEcShardsGenerateRequest, opts ...grpc.CallOption) (*VolumeEcShardsGenerateResponse, error) {
	out := new(VolumeEcShardsGenerateResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/VolumeEcShardsGenerate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) VolumeEcShardsRebuild(ctx context.Context, in *VolumeEcShardsRebuildRequest, opts ...grpc.CallOption) (*VolumeEcShardsRebuildResponse, error) {
	out := new(VolumeEcShardsRebuildResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/VolumeEcShardsRebuild", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) VolumeEcShardsCopy(ctx context.Context, in *VolumeEcShardsCopyRequest, opts ...grpc.CallOption) (*VolumeEcShardsCopyResponse, error) {
	out := new(VolumeEcShardsCopyResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/VolumeEcShardsCopy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) VolumeEcShardsDelete(ctx context.Context, in *VolumeEcShardsDeleteRequest, opts ...grpc.CallOption) (*VolumeEcShardsDeleteResponse, error) {
	out := new(VolumeEcShardsDeleteResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/VolumeEcShardsDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) VolumeEcShardsMount(ctx context.Context, in *VolumeEcShardsMountRequest, opts ...grpc.CallOption) (*VolumeEcShardsMountResponse, error) {
	out := new(VolumeEcShardsMountResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/VolumeEcShardsMount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) VolumeEcShardsUnmount(ctx context.Context, in *VolumeEcShardsUnmountRequest, opts ...grpc.CallOption) (*VolumeEcShardsUnmountResponse, error) {
	out := new(VolumeEcShardsUnmountResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/VolumeEcShardsUnmount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) VolumeEcShardRead(ctx context.Context, in *VolumeEcShardReadRequest, opts ...grpc.CallOption) (Volume_VolumeEcShardReadClient, error) {
	stream, err := c.cc.NewStream(ctx, &Volume_ServiceDesc.Streams[6], "/weed.volume.Volume/VolumeEcShardRead", opts...)
	if err != nil {
		return nil, err
	}
	x := &volumeVolumeEcShardReadClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Volume_VolumeEcShardReadClient interface {
	Recv() (*VolumeEcShardReadResponse, error)
	grpc.ClientStream
}

type volumeVolumeEcShardReadClient struct {
	grpc.ClientStream
}

func (x *volumeVolumeEcShardReadClient) Recv() (*VolumeEcShardReadResponse, error) {
	m := new(VolumeEcShardReadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *volumeClient) VolumeEcBlobDelete(ctx context.Context, in *VolumeEcBlobDeleteRequest, opts ...grpc.CallOption) (*VolumeEcBlobDeleteResponse, error) {
	out := new(VolumeEcBlobDeleteResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/VolumeEcBlobDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) VolumeEcShardsToVolume(ctx context.Context, in *VolumeEcShardsToVolumeRequest, opts ...grpc.CallOption) (*VolumeEcShardsToVolumeResponse, error) {
	out := new(VolumeEcShardsToVolumeResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/VolumeEcShardsToVolume", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) VolumeTierMoveDatToRemote(ctx context.Context, in *VolumeTierMoveDatToRemoteRequest, opts ...grpc.CallOption) (Volume_VolumeTierMoveDatToRemoteClient, error) {
	stream, err := c.cc.NewStream(ctx, &Volume_ServiceDesc.Streams[7], "/weed.volume.Volume/VolumeTierMoveDatToRemote", opts...)
	if err != nil {
		return nil, err
	}
	x := &volumeVolumeTierMoveDatToRemoteClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Volume_VolumeTierMoveDatToRemoteClient interface {
	Recv() (*VolumeTierMoveDatToRemoteResponse, error)
	grpc.ClientStream
}

type volumeVolumeTierMoveDatToRemoteClient struct {
	grpc.ClientStream
}

func (x *volumeVolumeTierMoveDatToRemoteClient) Recv() (*VolumeTierMoveDatToRemoteResponse, error) {
	m := new(VolumeTierMoveDatToRemoteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *volumeClient) VolumeTierMoveDatFromRemote(ctx context.Context, in *VolumeTierMoveDatFromRemoteRequest, opts ...grpc.CallOption) (Volume_VolumeTierMoveDatFromRemoteClient, error) {
	stream, err := c.cc.NewStream(ctx, &Volume_ServiceDesc.Streams[8], "/weed.volume.Volume/VolumeTierMoveDatFromRemote", opts...)
	if err != nil {
		return nil, err
	}
	x := &volumeVolumeTierMoveDatFromRemoteClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Volume_VolumeTierMoveDatFromRemoteClient interface {
	Recv() (*VolumeTierMoveDatFromRemoteResponse, error)
	grpc.ClientStream
}

type volumeVolumeTierMoveDatFromRemoteClient struct {
	grpc.ClientStream
}

func (x *volumeVolumeTierMoveDatFromRemoteClient) Recv() (*VolumeTierMoveDatFromRemoteResponse, error) {
	m := new(VolumeTierMoveDatFromRemoteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *volumeClient) VolumeServerStatus(ctx context.Context, in *VolumeServerStatusRequest, opts ...grpc.CallOption) (*VolumeServerStatusResponse, error) {
	out := new(VolumeServerStatusResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/VolumeServerStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) VolumeServerLeave(ctx context.Context, in *VolumeServerLeaveRequest, opts ...grpc.CallOption) (*VolumeServerLeaveResponse, error) {
	out := new(VolumeServerLeaveResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/VolumeServerLeave", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) FetchAndWriteNeedle(ctx context.Context, in *FetchAndWriteNeedleRequest, opts ...grpc.CallOption) (*FetchAndWriteNeedleResponse, error) {
	out := new(FetchAndWriteNeedleResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/FetchAndWriteNeedle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (Volume_QueryClient, error) {
	stream, err := c.cc.NewStream(ctx, &Volume_ServiceDesc.Streams[9], "/weed.volume.Volume/Query", opts...)
	if err != nil {
		return nil, err
	}
	x := &volumeQueryClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Volume_QueryClient interface {
	Recv() (*QueriedStripe, error)
	grpc.ClientStream
}

type volumeQueryClient struct {
	grpc.ClientStream
}

func (x *volumeQueryClient) Recv() (*QueriedStripe, error) {
	m := new(QueriedStripe)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *volumeClient) VolumeNeedleStatus(ctx context.Context, in *VolumeNeedleStatusRequest, opts ...grpc.CallOption) (*VolumeNeedleStatusResponse, error) {
	out := new(VolumeNeedleStatusResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/VolumeNeedleStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error) {
	out := new(PingResponse)
	err := c.cc.Invoke(ctx, "/weed.volume.Volume/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VolumeServer is the server API for Volume service.
// All implementations must embed UnimplementedVolumeServer
// for forward compatibility
type VolumeServer interface {
	//Experts only: takes multiple fid parameters. This function does not propagate deletes to replicas.
	BatchDelete(context.Context, *BatchDeleteRequest) (*BatchDeleteResponse, error)
	VacuumVolumeCheck(context.Context, *VacuumVolumeCheckRequest) (*VacuumVolumeCheckResponse, error)
	VacuumVolumeCompact(*VacuumVolumeCompactRequest, Volume_VacuumVolumeCompactServer) error
	VacuumVolumeCommit(context.Context, *VacuumVolumeCommitRequest) (*VacuumVolumeCommitResponse, error)
	VacuumVolumeCleanup(context.Context, *VacuumVolumeCleanupRequest) (*VacuumVolumeCleanupResponse, error)
	DeleteCollection(context.Context, *DeleteCollectionRequest) (*DeleteCollectionResponse, error)
	AllocateVolume(context.Context, *AllocateVolumeRequest) (*AllocateVolumeResponse, error)
	VolumeSyncStatus(context.Context, *VolumeSyncStatusRequest) (*VolumeSyncStatusResponse, error)
	VolumeIncrementalCopy(*VolumeIncrementalCopyRequest, Volume_VolumeIncrementalCopyServer) error
	VolumeMount(context.Context, *VolumeMountRequest) (*VolumeMountResponse, error)
	VolumeUnmount(context.Context, *VolumeUnmountRequest) (*VolumeUnmountResponse, error)
	VolumeDelete(context.Context, *VolumeDeleteRequest) (*VolumeDeleteResponse, error)
	VolumeMarkReadonly(context.Context, *VolumeMarkReadonlyRequest) (*VolumeMarkReadonlyResponse, error)
	VolumeMarkWritable(context.Context, *VolumeMarkWritableRequest) (*VolumeMarkWritableResponse, error)
	VolumeConfigure(context.Context, *VolumeConfigureRequest) (*VolumeConfigureResponse, error)
	VolumeStatus(context.Context, *VolumeStatusRequest) (*VolumeStatusResponse, error)
	// copy the .idx .dat files, and mount this volume
	VolumeCopy(*VolumeCopyRequest, Volume_VolumeCopyServer) error
	ReadVolumeFileStatus(context.Context, *ReadVolumeFileStatusRequest) (*ReadVolumeFileStatusResponse, error)
	CopyFile(*CopyFileRequest, Volume_CopyFileServer) error
	ReadNeedleBlob(context.Context, *ReadNeedleBlobRequest) (*ReadNeedleBlobResponse, error)
	WriteNeedleBlob(context.Context, *WriteNeedleBlobRequest) (*WriteNeedleBlobResponse, error)
	ReadAllNeedles(*ReadAllNeedlesRequest, Volume_ReadAllNeedlesServer) error
	VolumeTailSender(*VolumeTailSenderRequest, Volume_VolumeTailSenderServer) error
	VolumeTailReceiver(context.Context, *VolumeTailReceiverRequest) (*VolumeTailReceiverResponse, error)
	// erasure coding
	VolumeEcShardsGenerate(context.Context, *VolumeEcShardsGenerateRequest) (*VolumeEcShardsGenerateResponse, error)
	VolumeEcShardsRebuild(context.Context, *VolumeEcShardsRebuildRequest) (*VolumeEcShardsRebuildResponse, error)
	VolumeEcShardsCopy(context.Context, *VolumeEcShardsCopyRequest) (*VolumeEcShardsCopyResponse, error)
	VolumeEcShardsDelete(context.Context, *VolumeEcShardsDeleteRequest) (*VolumeEcShardsDeleteResponse, error)
	VolumeEcShardsMount(context.Context, *VolumeEcShardsMountRequest) (*VolumeEcShardsMountResponse, error)
	VolumeEcShardsUnmount(context.Context, *VolumeEcShardsUnmountRequest) (*VolumeEcShardsUnmountResponse, error)
	VolumeEcShardRead(*VolumeEcShardReadRequest, Volume_VolumeEcShardReadServer) error
	VolumeEcBlobDelete(context.Context, *VolumeEcBlobDeleteRequest) (*VolumeEcBlobDeleteResponse, error)
	VolumeEcShardsToVolume(context.Context, *VolumeEcShardsToVolumeRequest) (*VolumeEcShardsToVolumeResponse, error)
	// tiered storage
	VolumeTierMoveDatToRemote(*VolumeTierMoveDatToRemoteRequest, Volume_VolumeTierMoveDatToRemoteServer) error
	VolumeTierMoveDatFromRemote(*VolumeTierMoveDatFromRemoteRequest, Volume_VolumeTierMoveDatFromRemoteServer) error
	VolumeServerStatus(context.Context, *VolumeServerStatusRequest) (*VolumeServerStatusResponse, error)
	VolumeServerLeave(context.Context, *VolumeServerLeaveRequest) (*VolumeServerLeaveResponse, error)
	// remote storage
	FetchAndWriteNeedle(context.Context, *FetchAndWriteNeedleRequest) (*FetchAndWriteNeedleResponse, error)
	// <experimental> query
	Query(*QueryRequest, Volume_QueryServer) error
	VolumeNeedleStatus(context.Context, *VolumeNeedleStatusRequest) (*VolumeNeedleStatusResponse, error)
	Ping(context.Context, *PingRequest) (*PingResponse, error)
	mustEmbedUnimplementedVolumeServer()
}

// UnimplementedVolumeServer must be embedded to have forward compatible implementations.
type UnimplementedVolumeServer struct {
}

func (UnimplementedVolumeServer) BatchDelete(context.Context, *BatchDeleteRequest) (*BatchDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchDelete not implemented")
}
func (UnimplementedVolumeServer) VacuumVolumeCheck(context.Context, *VacuumVolumeCheckRequest) (*VacuumVolumeCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VacuumVolumeCheck not implemented")
}
func (UnimplementedVolumeServer) VacuumVolumeCompact(*VacuumVolumeCompactRequest, Volume_VacuumVolumeCompactServer) error {
	return status.Errorf(codes.Unimplemented, "method VacuumVolumeCompact not implemented")
}
func (UnimplementedVolumeServer) VacuumVolumeCommit(context.Context, *VacuumVolumeCommitRequest) (*VacuumVolumeCommitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VacuumVolumeCommit not implemented")
}
func (UnimplementedVolumeServer) VacuumVolumeCleanup(context.Context, *VacuumVolumeCleanupRequest) (*VacuumVolumeCleanupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VacuumVolumeCleanup not implemented")
}
func (UnimplementedVolumeServer) DeleteCollection(context.Context, *DeleteCollectionRequest) (*DeleteCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCollection not implemented")
}
func (UnimplementedVolumeServer) AllocateVolume(context.Context, *AllocateVolumeRequest) (*AllocateVolumeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AllocateVolume not implemented")
}
func (UnimplementedVolumeServer) VolumeSyncStatus(context.Context, *VolumeSyncStatusRequest) (*VolumeSyncStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeSyncStatus not implemented")
}
func (UnimplementedVolumeServer) VolumeIncrementalCopy(*VolumeIncrementalCopyRequest, Volume_VolumeIncrementalCopyServer) error {
	return status.Errorf(codes.Unimplemented, "method VolumeIncrementalCopy not implemented")
}
func (UnimplementedVolumeServer) VolumeMount(context.Context, *VolumeMountRequest) (*VolumeMountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeMount not implemented")
}
func (UnimplementedVolumeServer) VolumeUnmount(context.Context, *VolumeUnmountRequest) (*VolumeUnmountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeUnmount not implemented")
}
func (UnimplementedVolumeServer) VolumeDelete(context.Context, *VolumeDeleteRequest) (*VolumeDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeDelete not implemented")
}
func (UnimplementedVolumeServer) VolumeMarkReadonly(context.Context, *VolumeMarkReadonlyRequest) (*VolumeMarkReadonlyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeMarkReadonly not implemented")
}
func (UnimplementedVolumeServer) VolumeMarkWritable(context.Context, *VolumeMarkWritableRequest) (*VolumeMarkWritableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeMarkWritable not implemented")
}
func (UnimplementedVolumeServer) VolumeConfigure(context.Context, *VolumeConfigureRequest) (*VolumeConfigureResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeConfigure not implemented")
}
func (UnimplementedVolumeServer) VolumeStatus(context.Context, *VolumeStatusRequest) (*VolumeStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeStatus not implemented")
}
func (UnimplementedVolumeServer) VolumeCopy(*VolumeCopyRequest, Volume_VolumeCopyServer) error {
	return status.Errorf(codes.Unimplemented, "method VolumeCopy not implemented")
}
func (UnimplementedVolumeServer) ReadVolumeFileStatus(context.Context, *ReadVolumeFileStatusRequest) (*ReadVolumeFileStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadVolumeFileStatus not implemented")
}
func (UnimplementedVolumeServer) CopyFile(*CopyFileRequest, Volume_CopyFileServer) error {
	return status.Errorf(codes.Unimplemented, "method CopyFile not implemented")
}
func (UnimplementedVolumeServer) ReadNeedleBlob(context.Context, *ReadNeedleBlobRequest) (*ReadNeedleBlobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadNeedleBlob not implemented")
}
func (UnimplementedVolumeServer) WriteNeedleBlob(context.Context, *WriteNeedleBlobRequest) (*WriteNeedleBlobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteNeedleBlob not implemented")
}
func (UnimplementedVolumeServer) ReadAllNeedles(*ReadAllNeedlesRequest, Volume_ReadAllNeedlesServer) error {
	return status.Errorf(codes.Unimplemented, "method ReadAllNeedles not implemented")
}
func (UnimplementedVolumeServer) VolumeTailSender(*VolumeTailSenderRequest, Volume_VolumeTailSenderServer) error {
	return status.Errorf(codes.Unimplemented, "method VolumeTailSender not implemented")
}
func (UnimplementedVolumeServer) VolumeTailReceiver(context.Context, *VolumeTailReceiverRequest) (*VolumeTailReceiverResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeTailReceiver not implemented")
}
func (UnimplementedVolumeServer) VolumeEcShardsGenerate(context.Context, *VolumeEcShardsGenerateRequest) (*VolumeEcShardsGenerateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeEcShardsGenerate not implemented")
}
func (UnimplementedVolumeServer) VolumeEcShardsRebuild(context.Context, *VolumeEcShardsRebuildRequest) (*VolumeEcShardsRebuildResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeEcShardsRebuild not implemented")
}
func (UnimplementedVolumeServer) VolumeEcShardsCopy(context.Context, *VolumeEcShardsCopyRequest) (*VolumeEcShardsCopyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeEcShardsCopy not implemented")
}
func (UnimplementedVolumeServer) VolumeEcShardsDelete(context.Context, *VolumeEcShardsDeleteRequest) (*VolumeEcShardsDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeEcShardsDelete not implemented")
}
func (UnimplementedVolumeServer) VolumeEcShardsMount(context.Context, *VolumeEcShardsMountRequest) (*VolumeEcShardsMountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeEcShardsMount not implemented")
}
func (UnimplementedVolumeServer) VolumeEcShardsUnmount(context.Context, *VolumeEcShardsUnmountRequest) (*VolumeEcShardsUnmountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeEcShardsUnmount not implemented")
}
func (UnimplementedVolumeServer) VolumeEcShardRead(*VolumeEcShardReadRequest, Volume_VolumeEcShardReadServer) error {
	return status.Errorf(codes.Unimplemented, "method VolumeEcShardRead not implemented")
}
func (UnimplementedVolumeServer) VolumeEcBlobDelete(context.Context, *VolumeEcBlobDeleteRequest) (*VolumeEcBlobDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeEcBlobDelete not implemented")
}
func (UnimplementedVolumeServer) VolumeEcShardsToVolume(context.Context, *VolumeEcShardsToVolumeRequest) (*VolumeEcShardsToVolumeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeEcShardsToVolume not implemented")
}
func (UnimplementedVolumeServer) VolumeTierMoveDatToRemote(*VolumeTierMoveDatToRemoteRequest, Volume_VolumeTierMoveDatToRemoteServer) error {
	return status.Errorf(codes.Unimplemented, "method VolumeTierMoveDatToRemote not implemented")
}
func (UnimplementedVolumeServer) VolumeTierMoveDatFromRemote(*VolumeTierMoveDatFromRemoteRequest, Volume_VolumeTierMoveDatFromRemoteServer) error {
	return status.Errorf(codes.Unimplemented, "method VolumeTierMoveDatFromRemote not implemented")
}
func (UnimplementedVolumeServer) VolumeServerStatus(context.Context, *VolumeServerStatusRequest) (*VolumeServerStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeServerStatus not implemented")
}
func (UnimplementedVolumeServer) VolumeServerLeave(context.Context, *VolumeServerLeaveRequest) (*VolumeServerLeaveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeServerLeave not implemented")
}
func (UnimplementedVolumeServer) FetchAndWriteNeedle(context.Context, *FetchAndWriteNeedleRequest) (*FetchAndWriteNeedleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FetchAndWriteNeedle not implemented")
}
func (UnimplementedVolumeServer) Query(*QueryRequest, Volume_QueryServer) error {
	return status.Errorf(codes.Unimplemented, "method Query not implemented")
}
func (UnimplementedVolumeServer) VolumeNeedleStatus(context.Context, *VolumeNeedleStatusRequest) (*VolumeNeedleStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeNeedleStatus not implemented")
}
func (UnimplementedVolumeServer) Ping(context.Context, *PingRequest) (*PingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedVolumeServer) mustEmbedUnimplementedVolumeServer() {}

// UnsafeVolumeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VolumeServer will
// result in compilation errors.
type UnsafeVolumeServer interface {
	mustEmbedUnimplementedVolumeServer()
}

func RegisterVolumeServer(s grpc.ServiceRegistrar, srv VolumeServer) {
	s.RegisterService(&Volume_ServiceDesc, srv)
}

func _Volume_BatchDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).BatchDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/BatchDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).BatchDelete(ctx, req.(*BatchDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_VacuumVolumeCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VacuumVolumeCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).VacuumVolumeCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/VacuumVolumeCheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).VacuumVolumeCheck(ctx, req.(*VacuumVolumeCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_VacuumVolumeCompact_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(VacuumVolumeCompactRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VolumeServer).VacuumVolumeCompact(m, &volumeVacuumVolumeCompactServer{stream})
}

type Volume_VacuumVolumeCompactServer interface {
	Send(*VacuumVolumeCompactResponse) error
	grpc.ServerStream
}

type volumeVacuumVolumeCompactServer struct {
	grpc.ServerStream
}

func (x *volumeVacuumVolumeCompactServer) Send(m *VacuumVolumeCompactResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Volume_VacuumVolumeCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VacuumVolumeCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).VacuumVolumeCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/VacuumVolumeCommit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).VacuumVolumeCommit(ctx, req.(*VacuumVolumeCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_VacuumVolumeCleanup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VacuumVolumeCleanupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).VacuumVolumeCleanup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/VacuumVolumeCleanup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).VacuumVolumeCleanup(ctx, req.(*VacuumVolumeCleanupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_DeleteCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).DeleteCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/DeleteCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).DeleteCollection(ctx, req.(*DeleteCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_AllocateVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AllocateVolumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).AllocateVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/AllocateVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).AllocateVolume(ctx, req.(*AllocateVolumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_VolumeSyncStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeSyncStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).VolumeSyncStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/VolumeSyncStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).VolumeSyncStatus(ctx, req.(*VolumeSyncStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_VolumeIncrementalCopy_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(VolumeIncrementalCopyRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VolumeServer).VolumeIncrementalCopy(m, &volumeVolumeIncrementalCopyServer{stream})
}

type Volume_VolumeIncrementalCopyServer interface {
	Send(*VolumeIncrementalCopyResponse) error
	grpc.ServerStream
}

type volumeVolumeIncrementalCopyServer struct {
	grpc.ServerStream
}

func (x *volumeVolumeIncrementalCopyServer) Send(m *VolumeIncrementalCopyResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Volume_VolumeMount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeMountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).VolumeMount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/VolumeMount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).VolumeMount(ctx, req.(*VolumeMountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_VolumeUnmount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeUnmountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).VolumeUnmount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/VolumeUnmount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).VolumeUnmount(ctx, req.(*VolumeUnmountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_VolumeDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).VolumeDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/VolumeDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).VolumeDelete(ctx, req.(*VolumeDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_VolumeMarkReadonly_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeMarkReadonlyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).VolumeMarkReadonly(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/VolumeMarkReadonly",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).VolumeMarkReadonly(ctx, req.(*VolumeMarkReadonlyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_VolumeMarkWritable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeMarkWritableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).VolumeMarkWritable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/VolumeMarkWritable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).VolumeMarkWritable(ctx, req.(*VolumeMarkWritableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_VolumeConfigure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).VolumeConfigure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/VolumeConfigure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).VolumeConfigure(ctx, req.(*VolumeConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_VolumeStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).VolumeStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/VolumeStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).VolumeStatus(ctx, req.(*VolumeStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_VolumeCopy_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(VolumeCopyRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VolumeServer).VolumeCopy(m, &volumeVolumeCopyServer{stream})
}

type Volume_VolumeCopyServer interface {
	Send(*VolumeCopyResponse) error
	grpc.ServerStream
}

type volumeVolumeCopyServer struct {
	grpc.ServerStream
}

func (x *volumeVolumeCopyServer) Send(m *VolumeCopyResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Volume_ReadVolumeFileStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadVolumeFileStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).ReadVolumeFileStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/ReadVolumeFileStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).ReadVolumeFileStatus(ctx, req.(*ReadVolumeFileStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_CopyFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CopyFileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VolumeServer).CopyFile(m, &volumeCopyFileServer{stream})
}

type Volume_CopyFileServer interface {
	Send(*CopyFileResponse) error
	grpc.ServerStream
}

type volumeCopyFileServer struct {
	grpc.ServerStream
}

func (x *volumeCopyFileServer) Send(m *CopyFileResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Volume_ReadNeedleBlob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadNeedleBlobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).ReadNeedleBlob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/ReadNeedleBlob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).ReadNeedleBlob(ctx, req.(*ReadNeedleBlobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_WriteNeedleBlob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteNeedleBlobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).WriteNeedleBlob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/WriteNeedleBlob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).WriteNeedleBlob(ctx, req.(*WriteNeedleBlobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_ReadAllNeedles_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReadAllNeedlesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VolumeServer).ReadAllNeedles(m, &volumeReadAllNeedlesServer{stream})
}

type Volume_ReadAllNeedlesServer interface {
	Send(*ReadAllNeedlesResponse) error
	grpc.ServerStream
}

type volumeReadAllNeedlesServer struct {
	grpc.ServerStream
}

func (x *volumeReadAllNeedlesServer) Send(m *ReadAllNeedlesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Volume_VolumeTailSender_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(VolumeTailSenderRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VolumeServer).VolumeTailSender(m, &volumeVolumeTailSenderServer{stream})
}

type Volume_VolumeTailSenderServer interface {
	Send(*VolumeTailSenderResponse) error
	grpc.ServerStream
}

type volumeVolumeTailSenderServer struct {
	grpc.ServerStream
}

func (x *volumeVolumeTailSenderServer) Send(m *VolumeTailSenderResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Volume_VolumeTailReceiver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeTailReceiverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).VolumeTailReceiver(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/VolumeTailReceiver",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).VolumeTailReceiver(ctx, req.(*VolumeTailReceiverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_VolumeEcShardsGenerate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeEcShardsGenerateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).VolumeEcShardsGenerate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/VolumeEcShardsGenerate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).VolumeEcShardsGenerate(ctx, req.(*VolumeEcShardsGenerateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_VolumeEcShardsRebuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeEcShardsRebuildRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).VolumeEcShardsRebuild(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/VolumeEcShardsRebuild",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).VolumeEcShardsRebuild(ctx, req.(*VolumeEcShardsRebuildRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_VolumeEcShardsCopy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeEcShardsCopyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).VolumeEcShardsCopy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/VolumeEcShardsCopy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).VolumeEcShardsCopy(ctx, req.(*VolumeEcShardsCopyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_VolumeEcShardsDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeEcShardsDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).VolumeEcShardsDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/VolumeEcShardsDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).VolumeEcShardsDelete(ctx, req.(*VolumeEcShardsDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_VolumeEcShardsMount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeEcShardsMountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).VolumeEcShardsMount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/VolumeEcShardsMount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).VolumeEcShardsMount(ctx, req.(*VolumeEcShardsMountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_VolumeEcShardsUnmount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeEcShardsUnmountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).VolumeEcShardsUnmount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/VolumeEcShardsUnmount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).VolumeEcShardsUnmount(ctx, req.(*VolumeEcShardsUnmountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_VolumeEcShardRead_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(VolumeEcShardReadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VolumeServer).VolumeEcShardRead(m, &volumeVolumeEcShardReadServer{stream})
}

type Volume_VolumeEcShardReadServer interface {
	Send(*VolumeEcShardReadResponse) error
	grpc.ServerStream
}

type volumeVolumeEcShardReadServer struct {
	grpc.ServerStream
}

func (x *volumeVolumeEcShardReadServer) Send(m *VolumeEcShardReadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Volume_VolumeEcBlobDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeEcBlobDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).VolumeEcBlobDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/VolumeEcBlobDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).VolumeEcBlobDelete(ctx, req.(*VolumeEcBlobDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_VolumeEcShardsToVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeEcShardsToVolumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).VolumeEcShardsToVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/VolumeEcShardsToVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).VolumeEcShardsToVolume(ctx, req.(*VolumeEcShardsToVolumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_VolumeTierMoveDatToRemote_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(VolumeTierMoveDatToRemoteRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VolumeServer).VolumeTierMoveDatToRemote(m, &volumeVolumeTierMoveDatToRemoteServer{stream})
}

type Volume_VolumeTierMoveDatToRemoteServer interface {
	Send(*VolumeTierMoveDatToRemoteResponse) error
	grpc.ServerStream
}

type volumeVolumeTierMoveDatToRemoteServer struct {
	grpc.ServerStream
}

func (x *volumeVolumeTierMoveDatToRemoteServer) Send(m *VolumeTierMoveDatToRemoteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Volume_VolumeTierMoveDatFromRemote_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(VolumeTierMoveDatFromRemoteRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VolumeServer).VolumeTierMoveDatFromRemote(m, &volumeVolumeTierMoveDatFromRemoteServer{stream})
}

type Volume_VolumeTierMoveDatFromRemoteServer interface {
	Send(*VolumeTierMoveDatFromRemoteResponse) error
	grpc.ServerStream
}

type volumeVolumeTierMoveDatFromRemoteServer struct {
	grpc.ServerStream
}

func (x *volumeVolumeTierMoveDatFromRemoteServer) Send(m *VolumeTierMoveDatFromRemoteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Volume_VolumeServerStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeServerStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).VolumeServerStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/VolumeServerStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).VolumeServerStatus(ctx, req.(*VolumeServerStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_VolumeServerLeave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeServerLeaveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).VolumeServerLeave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/VolumeServerLeave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).VolumeServerLeave(ctx, req.(*VolumeServerLeaveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_FetchAndWriteNeedle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchAndWriteNeedleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).FetchAndWriteNeedle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/FetchAndWriteNeedle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).FetchAndWriteNeedle(ctx, req.(*FetchAndWriteNeedleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_Query_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(QueryRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VolumeServer).Query(m, &volumeQueryServer{stream})
}

type Volume_QueryServer interface {
	Send(*QueriedStripe) error
	grpc.ServerStream
}

type volumeQueryServer struct {
	grpc.ServerStream
}

func (x *volumeQueryServer) Send(m *QueriedStripe) error {
	return x.ServerStream.SendMsg(m)
}

func _Volume_VolumeNeedleStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeNeedleStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).VolumeNeedleStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/VolumeNeedleStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).VolumeNeedleStatus(ctx, req.(*VolumeNeedleStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volume_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weed.volume.Volume/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServer).Ping(ctx, req.(*PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Volume_ServiceDesc is the grpc.ServiceDesc for Volume service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Volume_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "weed.volume.Volume",
	HandlerType: (*VolumeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BatchDelete",
			Handler:    _Volume_BatchDelete_Handler,
		},
		{
			MethodName: "VacuumVolumeCheck",
			Handler:    _Volume_VacuumVolumeCheck_Handler,
		},
		{
			MethodName: "VacuumVolumeCommit",
			Handler:    _Volume_VacuumVolumeCommit_Handler,
		},
		{
			MethodName: "VacuumVolumeCleanup",
			Handler:    _Volume_VacuumVolumeCleanup_Handler,
		},
		{
			MethodName: "DeleteCollection",
			Handler:    _Volume_DeleteCollection_Handler,
		},
		{
			MethodName: "AllocateVolume",
			Handler:    _Volume_AllocateVolume_Handler,
		},
		{
			MethodName: "VolumeSyncStatus",
			Handler:    _Volume_VolumeSyncStatus_Handler,
		},
		{
			MethodName: "VolumeMount",
			Handler:    _Volume_VolumeMount_Handler,
		},
		{
			MethodName: "VolumeUnmount",
			Handler:    _Volume_VolumeUnmount_Handler,
		},
		{
			MethodName: "VolumeDelete",
			Handler:    _Volume_VolumeDelete_Handler,
		},
		{
			MethodName: "VolumeMarkReadonly",
			Handler:    _Volume_VolumeMarkReadonly_Handler,
		},
		{
			MethodName: "VolumeMarkWritable",
			Handler:    _Volume_VolumeMarkWritable_Handler,
		},
		{
			MethodName: "VolumeConfigure",
			Handler:    _Volume_VolumeConfigure_Handler,
		},
		{
			MethodName: "VolumeStatus",
			Handler:    _Volume_VolumeStatus_Handler,
		},
		{
			MethodName: "ReadVolumeFileStatus",
			Handler:    _Volume_ReadVolumeFileStatus_Handler,
		},
		{
			MethodName: "ReadNeedleBlob",
			Handler:    _Volume_ReadNeedleBlob_Handler,
		},
		{
			MethodName: "WriteNeedleBlob",
			Handler:    _Volume_WriteNeedleBlob_Handler,
		},
		{
			MethodName: "VolumeTailReceiver",
			Handler:    _Volume_VolumeTailReceiver_Handler,
		},
		{
			MethodName: "VolumeEcShardsGenerate",
			Handler:    _Volume_VolumeEcShardsGenerate_Handler,
		},
		{
			MethodName: "VolumeEcShardsRebuild",
			Handler:    _Volume_VolumeEcShardsRebuild_Handler,
		},
		{
			MethodName: "VolumeEcShardsCopy",
			Handler:    _Volume_VolumeEcShardsCopy_Handler,
		},
		{
			MethodName: "VolumeEcShardsDelete",
			Handler:    _Volume_VolumeEcShardsDelete_Handler,
		},
		{
			MethodName: "VolumeEcShardsMount",
			Handler:    _Volume_VolumeEcShardsMount_Handler,
		},
		{
			MethodName: "VolumeEcShardsUnmount",
			Handler:    _Volume_VolumeEcShardsUnmount_Handler,
		},
		{
			MethodName: "VolumeEcBlobDelete",
			Handler:    _Volume_VolumeEcBlobDelete_Handler,
		},
		{
			MethodName: "VolumeEcShardsToVolume",
			Handler:    _Volume_VolumeEcShardsToVolume_Handler,
		},
		{
			MethodName: "VolumeServerStatus",
			Handler:    _Volume_VolumeServerStatus_Handler,
		},
		{
			MethodName: "VolumeServerLeave",
			Handler:    _Volume_VolumeServerLeave_Handler,
		},
		{
			MethodName: "FetchAndWriteNeedle",
			Handler:    _Volume_FetchAndWriteNeedle_Handler,
		},
		{
			MethodName: "VolumeNeedleStatus",
			Handler:    _Volume_VolumeNeedleStatus_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _Volume_Ping_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "VacuumVolumeCompact",
			Handler:       _Volume_VacuumVolumeCompact_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "VolumeIncrementalCopy",
			Handler:       _Volume_VolumeIncrementalCopy_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "VolumeCopy",
			Handler:       _Volume_VolumeCopy_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CopyFile",
			Handler:       _Volume_CopyFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ReadAllNeedles",
			Handler:       _Volume_ReadAllNeedles_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "VolumeTailSender",
			Handler:       _Volume_VolumeTailSender_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "VolumeEcShardRead",
			Handler:       _Volume_VolumeEcShardRead_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "VolumeTierMoveDatToRemote",
			Handler:       _Volume_VolumeTierMoveDatToRemote_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "VolumeTierMoveDatFromRemote",
			Handler:       _Volume_VolumeTierMoveDatFromRemote_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Query",
			Handler:       _Volume_Query_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "volume.proto",
}
